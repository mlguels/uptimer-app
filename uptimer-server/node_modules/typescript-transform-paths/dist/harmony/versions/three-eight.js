"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.predicate = void 0;
exports.handler = handler;
exports.downSample = downSample;
// endregion
/* ****************************************************************************************************************** */
// region: Utils
/* ****************************************************************************************************************** */
const predicate = (context) => context.tsVersionMajor < 4;
exports.predicate = predicate;
function handler(context, prop) {
    const ts = context.tsInstance;
    switch (prop) {
        case "updateCallExpression":
            return (...args) => ts.updateCall.apply(void 0, args);
        case "updateImportClause":
            return function (node, isTypeOnly, name, namedBindings) {
                // @ts-expect-error TODO investigate type issue
                return ts.updateImportClause.apply(void 0, downSample(node, name, namedBindings));
            };
        case "updateImportDeclaration":
            return function (node, modifiers, importClause, moduleSpecifier) {
                const [dsNode, dsImportClause, dsModuleSpecifier] = downSample(node, importClause, moduleSpecifier);
                return ts.updateImportDeclaration(dsNode, dsNode.decorators, dsNode.modifiers, dsImportClause, dsModuleSpecifier);
            };
        case "updateExportDeclaration":
            return function (node, modifiers, isTypeOnly, exportClause, moduleSpecifier) {
                const [dsNode, dsModuleSpecifier, dsExportClause] = downSample(node, moduleSpecifier, exportClause);
                return ts.updateExportDeclaration(dsNode, dsNode.decorators, dsNode.modifiers, dsExportClause, dsModuleSpecifier, dsNode.isTypeOnly);
            };
        case "updateModuleDeclaration":
            return function (node, modifiers, name, body) {
                const [dsNode, dsName, dsBody] = downSample(node, name, body);
                return ts.updateModuleDeclaration(dsNode, dsNode.decorators, dsNode.modifiers, dsName, dsBody);
            };
        case "updateImportTypeNode":
            return function (node, argument, assertions, qualifier, typeArguments, isTypeOf) {
                const [dsNode, dsArgument, dsQualifier, dsTypeArguments] = downSample(node, argument, qualifier, typeArguments);
                return ts.updateImportTypeNode(dsNode, dsArgument, dsQualifier, dsTypeArguments, isTypeOf);
            };
        default:
            return (...args) => ts[prop](...args);
    }
}
function downSample(...args) {
    return args;
}
// endregion
//# sourceMappingURL=three-eight.js.map